#!/bin/bash
# scdf_install_k8s.sh: Installs SCDF on Kubernetes
# Usage: ./scdf_install_k8s.sh > logs/scdf_install_k8s.log 2>&1

# --- Step Counter (must be set before any function uses it) ---
STEP_COUNTER=0
# Set STEP_TOTAL to the number of step_major calls in this script (do NOT include step 0)
STEP_TOTAL=$(grep -c '^\s*step_major ' "$0")
export STEP_TOTAL

# --- Prerequisite Checks (Step 0 of N) ---
printf -v STEP_0_FMT "\033[1;32m[0/%d] Checking prerequisites (kubectl, helm, yq) ...\033[0m" "$STEP_TOTAL"
echo -e "$STEP_0_FMT"
REQUIRED_TOOLS=(kubectl helm yq)
MISSING_TOOLS=()
for tool in "${REQUIRED_TOOLS[@]}"; do
  if ! command -v "$tool" >/dev/null 2>&1; then
    MISSING_TOOLS+=("$tool")
  fi
done
if [ ${#MISSING_TOOLS[@]} -ne 0 ]; then
  echo "[ERROR] The following required tools are missing: ${MISSING_TOOLS[*]}" >&2
  echo "Please install them before running this script. See README.md for instructions." >&2
  exit 1
fi

# --- Logging Setup ---
LOGDIR="$(pwd)/logs"
mkdir -p "$LOGDIR"
LOGFILE="$LOGDIR/scdf_install_k8s.log"

# --- Source environment variables ---
if [ -f "./scdf_env.properties" ]; then
  set -o allexport
  source ./scdf_env.properties
  set +o allexport
else
  echo "[ERROR] scdf_env.properties not found! Please create it or check the path." >&2
  exit 1
fi

# --- Namespace Setup ---
NAMESPACE="${NAMESPACE:-scdf}"
POSTGRES_RELEASE_NAME="${POSTGRES_RELEASE_NAME:-scdf-postgres}"

# --- Utility Functions ---
# Print an informational message to log file only (does not increment step counter)
step_minor() {
  echo "    [INFO] $1" >>"$LOGFILE"
}
# Print a cyan status message to log file only
status() {
  echo "    [STATUS] $1" >>"$LOGFILE"
}
# Print a completion message in [N/TOTAL] format, to terminal and log
step_done() {
  echo -e "\033[1;36m[$STEP_COUNTER/$STEP_TOTAL] COMPLETE: $STEP_LAST\033[0m" >&2
  echo "[$STEP_COUNTER/$STEP_TOTAL] COMPLETE: $STEP_LAST" >>"$LOGFILE"
}
# Print a red error message to terminal
err() { echo -e "\033[1;31m$1\033[0m" >&2; }

step_major() {
  STEP_COUNTER=$((STEP_COUNTER+1))
  STEP_LAST="$1"
  echo -e "\033[1;32m[$STEP_COUNTER/$STEP_TOTAL] $1\033[0m" >&2
  echo "[$STEP_COUNTER/$STEP_TOTAL] $1" >>"$LOGFILE"
}
# Removed unnecessary function exports that cause errors in some shells
# export -f step_done
# export -f status

# Wait for a Kubernetes pod to be ready
wait_for_ready() {
  local NAME_SUBSTR=$1
  local TIMEOUT=${2:-300}
  local ELAPSED=0
  local INTERVAL=5
  while (( ELAPSED < TIMEOUT )); do
    POD=$(kubectl get pods -n "$NAMESPACE" --no-headers | grep "$NAME_SUBSTR" | awk '{print $1}')
    echo "[wait_for_ready] Checking for pod with substring '$NAME_SUBSTR' (elapsed: $ELAPSED)" >>"$LOGFILE"
    if [[ -n "$POD" ]]; then
      PHASE=$(kubectl get pod "$POD" -n "$NAMESPACE" -o jsonpath="{.status.phase}")
      READY=$(kubectl get pod "$POD" -n "$NAMESPACE" -o jsonpath="{.status.containerStatuses[*].ready}")
      echo "[wait_for_ready] Pod: $POD, Phase: $PHASE, Ready: $READY" >>"$LOGFILE"
      if [[ "$PHASE" == "Running" && "$READY" == *"true"* ]]; then
        status "$NAME_SUBSTR pod '$POD' is running and ready."
        echo "[wait_for_ready] $NAME_SUBSTR pod '$POD' is running and ready." >>"$LOGFILE"
        return 0
      fi
    fi
    sleep $INTERVAL
    ((ELAPSED+=INTERVAL))
  done
  err "Timed out waiting for pod with name containing '$NAME_SUBSTR' to be ready."
  echo "[wait_for_ready] Timed out waiting for pod with name containing '$NAME_SUBSTR' to be ready." >>"$LOGFILE"
  exit 1
}

# Download the SCDF Shell JAR if not present
# Usage: download_shell_jar
# Ensures $SHELL_JAR exists
download_shell_jar() {
  if [[ ! -f "$SHELL_JAR" ]]; then
    step_minor "Downloading SCDF Shell JAR..."
    curl -fsSL -o "$SHELL_JAR" "$SHELL_URL" >>"$LOGFILE" 2>&1 || { err "Failed to download SCDF Shell JAR"; exit 1; }
    step_done "SCDF Shell JAR downloaded."
  else
    step_minor "SCDF Shell JAR already present."
    step_done "SCDF Shell JAR already present."
  fi
}

# Register all default apps as Docker images
# Usage: register_default_apps
register_default_apps() {
  step_minor "Downloading default Docker app list..."
  curl -fsSL "$DEFAULT_DOCKER_APPS_URI" -o "$DOCKER_APPS_FILE" >>"$LOGFILE" 2>&1 || { err "Failed to download $DEFAULT_DOCKER_APPS_URI"; echo "[register_default_apps] Failed to download $DEFAULT_DOCKER_APPS_URI" >>"$LOGFILE"; exit 1; }
  step_done "Default Docker app list downloaded."
  step_minor "Registering all default apps as Docker images..."
  local failed=0
  while IFS= read -r line; do
    [[ "$line" =~ ^#.*$ || -z "$line" || "$line" == *":jar:metadata"* ]] && continue
    key="${line%%=*}"
    uri="${line#*=}"
    type="${key%%.*}"
    name="${key#*.}"
    [[ "$uri" != docker:* ]] && continue
    REG_URL="$SCDF_SERVER_URL/apps/$type/$name"
    step_minor "Registering $type:$name -> $uri"
    echo "[register_default_apps] Registering $type:$name -> $uri ($REG_URL)" >>"$LOGFILE"
    REG_OUTPUT=$(curl -s -w "\n%{http_code}" -X POST "$REG_URL" -d "uri=$uri" 2>&1)
    HTTP_CODE=$(echo "$REG_OUTPUT" | tail -n1)
    BODY=$(echo "$REG_OUTPUT" | sed '$d')
    echo "[register_default_apps] Response: HTTP $HTTP_CODE, Body: $BODY" >>"$LOGFILE"
    echo "$type.$name=$uri -> $HTTP_CODE" >> "$LOGFILE"
    if [[ "$HTTP_CODE" != "201" ]]; then
      err "Failed to register $type:$name ($HTTP_CODE)."
      echo "[register_default_apps] Failed to register $type:$name ($HTTP_CODE). Body: $BODY" >>"$LOGFILE"
      echo -e "\033[1;31m[REGISTRATION ERROR] $type:$name ($HTTP_CODE): $BODY\033[0m" >&2
      failed=1
    fi
  done < "$APPS_PROPS_FILE_DOCKER"
  step_done "Default Docker applications registration complete."
  echo "[register_default_apps] Registration process complete." >>"$LOGFILE"
  if [ $failed -eq 1 ]; then
    echo -e "\033[1;31mSome or all app registrations failed. See $LOGFILE for details.\033[0m" >&2
  fi
}

# Register all default apps as Maven artifacts
# Usage: register_default_apps_maven
register_default_apps_maven() {
  step_minor "Registering all default apps as Maven artifacts..."
  local failed=0
  while IFS= read -r line; do
    [[ "$line" =~ ^#.*$ || -z "$line" || "$line" == *":jar:metadata"* ]] && continue
    key="${line%%=*}"
    uri="${line#*=}"
    type="${key%%.*}"
    name="${key#*.}"
    [[ "$uri" != maven:* ]] && continue
    REG_URL="$SCDF_SERVER_URL/apps/$type/$name"
    step_minor "Registering $type:$name -> $uri"
    echo "[register_default_apps_maven] Registering $type:$name -> $uri ($REG_URL)" >>"$LOGFILE"
    REG_OUTPUT=$(curl -s -w "\n%{http_code}" -X POST "$REG_URL" -d "uri=$uri" 2>&1)
    HTTP_CODE=$(echo "$REG_OUTPUT" | tail -n1)
    BODY=$(echo "$REG_OUTPUT" | sed '$d')
    echo "[register_default_apps_maven] Response: HTTP $HTTP_CODE, Body: $BODY" >>"$LOGFILE"
    echo "$type.$name=$uri -> $HTTP_CODE" >> "$LOGFILE"
    if [[ "$HTTP_CODE" != "201" ]]; then
      err "Failed to register $type:$name ($HTTP_CODE)."
      echo "[register_default_apps_maven] Failed to register $type:$name ($HTTP_CODE). Body: $BODY" >>"$LOGFILE"
      echo -e "\033[1;31m[REGISTRATION ERROR] $type:$name ($HTTP_CODE): $BODY\033[0m" >&2
      failed=1
    fi
  done < "$APPS_PROPS_FILE_MAVEN"
  step_done "Default Maven applications registration complete."
  echo "[register_default_apps_maven] Registration process complete." >>"$LOGFILE"
  if [ $failed -eq 1 ]; then
    echo -e "\033[1;31mSome or all Maven app registrations failed. See $LOGFILE for details.\033[0m" >&2
  fi
}

# Print management URLs
print_management_urls() {
  {
    echo "--- Management URLs and Credentials ---"
    echo "SCDF Dashboard:    http://127.0.0.1:30080/dashboard"
    echo "RabbitMQ MGMT UI:  http://127.0.0.1:$RABBITMQ_NODEPORT_MANAGER [$RABBITMQ_USER/$RABBITMQ_PASSWORD]"
    echo "RabbitMQ AMQP:     localhost:$RABBITMQ_NODEPORT_AMQP [$RABBITMQ_USER/$RABBITMQ_PASSWORD]"
    echo "PostgreSQL:        localhost:$POSTGRES_NODEPORT [$POSTGRES_USER/$POSTGRES_PASSWORD, DB: $POSTGRES_DB]"
    echo "Ollama (nomic):    http://ollama-nomic.$NAMESPACE.svc.cluster.local:11434 [internal K8s]"
    echo "Ollama (nomic, local): http://127.0.0.1:11434 [if port-forwarded]"
    MINIO_USER=$(kubectl get secret --namespace $NAMESPACE $MINIO_RELEASE -o jsonpath="{.data.root-user}" | base64 --decode 2>/dev/null)
    MINIO_PASS=$(kubectl get secret --namespace $NAMESPACE $MINIO_RELEASE -o jsonpath="{.data.root-password}" | base64 --decode 2>/dev/null)
    if [[ -n "$MINIO_USER" && -n "$MINIO_PASS" ]]; then
      echo "MinIO Credentials [Bitnami Helm chart default]:"
      echo "  Access Key: $MINIO_USER"
      echo "  Secret Key: $MINIO_PASS"
    fi
    echo "MinIO MGMT Console: http://127.0.0.1:${MINIO_CONSOLE_PORT}"
    echo "Namespace:         $NAMESPACE"
    echo "To stop services, delete the namespace or uninstall the Helm releases."
    echo "---"
    echo "Nomic Model Info:  Model 'nomic-embed-text' is available via the Ollama API."
    echo "  Example embedding endpoint: POST /api/embeddings to http://ollama-nomic.$NAMESPACE.svc.cluster.local:11434"
  } | tee -a "$LOGFILE"
}

# ----------------------------------------------------------------------
# SCDF Platform Deployer Properties for RabbitMQ (Kubernetes)
# ----------------------------------------------------------------------
#
# To set RabbitMQ connection properties globally for all apps deployed via SCDF
# on Kubernetes, use the Platform Deployer model. This ensures all apps inherit
# these settings by default (no need to specify at deploy-time).
#
# 1. In the SCDF UI:
#    - Go to "Platforms" (left nav)
#    - Click your Kubernetes platform (e.g., 'kubernetes')
#    - Click "Edit"
#    - Add the following under "Global Deployer Properties":
#      spring.rabbitmq.host=$RABBIT_HOST
#      spring.rabbitmq.port=$RABBIT_PORT
#      spring.rabbitmq.username=$RABBITMQ_USER
#      spring.rabbitmq.password=$RABBITMQ_PASSWORD
#    - Save and re-deploy your stream apps.
#
# 2. Alternatively, patch the ConfigMaps (automated below):
#    This script will patch both the SCDF server and skipper ConfigMaps using the
#    values from scdf_env.properties, and restart the deployments as needed.
# ----------------------------------------------------------------------

patch_scdf_rabbitmq_config() {
  echo "[INFO] Patching SCDF server and skipper application.yaml with RabbitMQ settings..." | tee -a "$LOGFILE"
  local ns="${NAMESPACE:-scdf}"
  for config in scdf-spring-cloud-dataflow-server scdf-spring-cloud-dataflow-skipper; do
    echo "  - Patching $config in namespace $ns" | tee -a "$LOGFILE"
    # Extract application.yaml
    kubectl get configmap $config -n "$ns" -o jsonpath='{.data.application\.yaml}' > app.yaml 2>>"$LOGFILE"
    # Merge rabbitmq block under spring using yq if available
    if command -v yq >/dev/null 2>&1; then
      yq e '.spring.rabbitmq.host = env(RABBIT_HOST) | .spring.rabbitmq.port = env(RABBIT_PORT) | .spring.rabbitmq.username = env(RABBITMQ_USER) | .spring.rabbitmq.password = env(RABBITMQ_PASSWORD)' app.yaml > app_merged.yaml
      mv app_merged.yaml app.yaml
      echo "[DEBUG] Merged RabbitMQ block using yq:" | tee -a "$LOGFILE"
      yq e '.spring.rabbitmq' app.yaml | tee -a "$LOGFILE"
    else
      # Fallback: If no spring block, prepend; if present, warn user
      if grep -q '^spring:' app.yaml; then
        echo "[ERROR] 'spring:' block already exists in app.yaml. Please install 'yq' for safe YAML merging." | tee -a "$LOGFILE"
        exit 1
      else
        cat <<EOF > app_rabbitmq.yaml
spring:
  rabbitmq:
    host: $RABBIT_HOST
    port: $RABBIT_PORT
    username: $RABBITMQ_USER
    password: $RABBITMQ_PASSWORD
EOF
        cat app.yaml >> app_rabbitmq.yaml
        mv app_rabbitmq.yaml app.yaml
        echo "[DEBUG] Added new spring.rabbitmq block." | tee -a "$LOGFILE"
      fi
    fi
    # Update the ConfigMap
    kubectl create configmap $config --from-file=application.yaml=app.yaml -n "$ns" --dry-run=client -o yaml | kubectl apply -f - >>"$LOGFILE" 2>&1
    rm app.yaml
  done
  echo "[INFO] Restarting SCDF server and skipper deployments to apply changes..." | tee -a "$LOGFILE"
  kubectl rollout restart deployment scdf-spring-cloud-dataflow-server -n "$ns" >>"$LOGFILE" 2>&1
  kubectl rollout restart deployment scdf-spring-cloud-dataflow-skipper -n "$ns" >>"$LOGFILE" 2>&1
  echo "[INFO] RabbitMQ configuration updated in application.yaml and deployments restarted." | tee -a "$LOGFILE"
}

install_minio() {
  step_major "Installing MinIO S3-compatible storage..."
  step_minor "Cleaning up old MinIO PVC and PV if they exist..."
  kubectl delete pvc $MINIO_PVC -n $NAMESPACE --ignore-not-found >>"$LOGFILE" 2>&1
  kubectl delete pv minio-pv --ignore-not-found >>"$LOGFILE" 2>&1

  step_minor "Applying MinIO PersistentVolume and PersistentVolumeClaim YAML..."
  mkdir -p resources
  SOURCE_DOCS_DIR="${MINIO_SOURCE_DIR:-$(pwd)/sourceDocs}"
  mkdir -p "$SOURCE_DOCS_DIR"
  cat > resources/minio-pv-pvc.yaml <<EOF
apiVersion: v1
kind: PersistentVolume
metadata:
  name: minio-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: $SOURCE_DOCS_DIR
  storageClassName: hostpath
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: $MINIO_PVC
  namespace: $NAMESPACE
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  volumeName: minio-pv
EOF
  kubectl apply -f resources/minio-pv-pvc.yaml >>"$LOGFILE" 2>&1

  step_minor "Adding Bitnami Helm repo and updating..."
  helm repo add bitnami https://charts.bitnami.com/bitnami >>"$LOGFILE" 2>&1 || true
  helm repo update >>"$LOGFILE" 2>&1

  step_minor "Installing MinIO via Helm using static hostPath PV..."
  helm upgrade --install $MINIO_RELEASE bitnami/minio \
    --namespace $NAMESPACE \
    --set persistence.existingClaim=$MINIO_PVC \
    --set mode=standalone \
    --set resources.requests.memory=512Mi \
    --set resources.requests.cpu=250m \
    --set service.type=NodePort \
    --set service.nodePorts.api=$MINIO_API_PORT \
    --set service.nodePorts.console=$MINIO_CONSOLE_PORT >>"$LOGFILE" 2>&1

  step_minor "Waiting for MinIO pod to be ready..."
  wait_for_ready minio 300
  # Print MinIO management (console) address
  MINIO_MGMT_URL="http://$(hostname -I | awk '{print $1}'):${MINIO_CONSOLE_PORT}"
  echo "MinIO Management Console: $MINIO_MGMT_URL" | tee -a "$LOGFILE"
  step_done "MinIO installation complete."
}

# --- Constants and Flags ---
SKIP_INSTALL=0
INSTALL_MODELS_ONLY=0
PRINT_URLS_ONLY=0
while [[ $# -gt 0 ]]; do
  case $1 in
    --skip-install)
      SKIP_INSTALL=1
      shift
      ;;
    --models-only)
      INSTALL_MODELS_ONLY=1
      shift
      ;;
    --print-urls)
      PRINT_URLS_ONLY=1
      shift
      ;;
    *)
      shift
      ;;
  esac
done

# --- Print URLs Only Mode ---
if [[ $PRINT_URLS_ONLY -eq 1 ]]; then
  print_management_urls
  exit 0
fi

# --- Main Install Logic ---
if [[ $INSTALL_MODELS_ONLY -eq 1 ]]; then
  # Only deploy the Ollama model service, skip cleanup and all other steps
  step_major "Creating namespace..."
  kubectl create namespace "$NAMESPACE" 2>/dev/null || true
  step_done "Namespace created."
  step_major "Deploying Ollama nomic-embed-text model as a Kubernetes service..."
  kubectl apply -f ollama-nomic.yaml -n "$NAMESPACE" >>"$LOGFILE" 2>&1
  wait_for_ready ollama-nomic
  step_done "Model-only install complete."
  exit 0
fi

# --- Full install: cleanup and all services ---
step_major "Cleaning up previous SCDF installs..."
helm uninstall scdf --namespace "$NAMESPACE" >>"$LOGFILE" 2>&1 || true
helm uninstall scdf-rabbitmq --namespace "$NAMESPACE" >>"$LOGFILE" 2>&1
step_done "Previous SCDF installs cleaned up."

# Wait for deployments to be deleted
step_major "Waiting for SCDF and RabbitMQ deployments to be deleted..."
for dep in scdf scdf-rabbitmq; do
  for i in {1..30}; do
    if ! kubectl get deployment "$dep" -n "$NAMESPACE" &>/dev/null; then
      status "$dep deployment deleted."
      break
    fi
    echo "[INFO] Waiting for $dep deployment to be deleted... [${i}/30]" >>"$LOGFILE"
    sleep 2
  done
done
step_done "SCDF and RabbitMQ deployments deleted."

step_major "Deleting namespace..."
kubectl delete namespace "$NAMESPACE" >>"$LOGFILE" 2>&1 || true
step_done "Namespace deleted."

for i in {1..60}; do
  if ! kubectl get namespace "$NAMESPACE" &>/dev/null; then
    status "Namespace $NAMESPACE deleted."
    break
  fi
  echo "[INFO] Waiting for namespace $NAMESPACE to be deleted... [${i}/60]" >>"$LOGFILE"
  sleep 2
done
step_done "Namespace deleted."

step_major "Creating namespace..."
kubectl create namespace "$NAMESPACE" >>"$LOGFILE" 2>&1 || true
step_done "Namespace created."

# --- Ollama with nomic-embed-text (K8s) ---
step_major "Deploying Ollama nomic-embed-text model as a Kubernetes service..."
kubectl apply -f ollama-nomic.yaml -n "$NAMESPACE" >>"$LOGFILE" 2>&1
wait_for_ready ollama-nomic
step_done "Ollama nomic-embed-text model deployed."

echo "[INFO] Running full install steps..." >>"$LOGFILE"

# --- Helm Repo and RabbitMQ ---
step_major "Adding/updating Helm repo..."
helm repo add bitnami https://charts.bitnami.com/bitnami >>"$LOGFILE" 2>&1 || true
helm repo update >>"$LOGFILE" 2>&1
step_done "Helm repo added/updated."

step_major "Installing RabbitMQ..."
helm upgrade --install "$RABBITMQ_RELEASE_NAME" bitnami/rabbitmq \
  --namespace "$NAMESPACE" \
  --set auth.username="$RABBITMQ_USER" \
  --set auth.password="$RABBITMQ_PASSWORD" \
  --set auth.erlangCookie="$RABBITMQ_ERLANG_COOKIE" \
  --set persistence.enabled=false \
  --set service.type=NodePort \
  --set service.nodePorts.amqp="$RABBITMQ_NODEPORT_AMQP" \
  --set service.nodePorts.manager="$RABBITMQ_NODEPORT_MANAGER" \
  >>"$LOGFILE" 2>&1 || true

i=0
# Wait for RabbitMQ pod to be ready, with status updates in log
while true; do
  READY=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/instance="$RABBITMQ_RELEASE_NAME" -o jsonpath='{.items[0].status.containerStatuses[0].ready}' 2>/dev/null)
  PHASE=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/instance="$RABBITMQ_RELEASE_NAME" -o jsonpath='{.items[0].status.phase}' 2>/dev/null)
  NAME=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/instance="$RABBITMQ_RELEASE_NAME" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
  if [[ "$READY" == "true" ]]; then
    echo "[STATUS] RabbitMQ pod $NAME is ready after $i seconds." >>"$LOGFILE"
    break
  fi
  if (( i % 15 == 0 )); then
    echo "[STATUS] Waiting for RabbitMQ pod ($NAME) to be ready... phase: $PHASE, ready: $READY, elapsed: ${i}s" >>"$LOGFILE"
  fi
  sleep 1
  ((i++))
  if (( i > 300 )); then
    echo "[ERROR] RabbitMQ pod did not become ready after 300 seconds." >>"$LOGFILE"
    break
  fi
done

step_done "RabbitMQ installed."

# --- PostgreSQL with pgvector ---
step_major "Installing PostgreSQL with pgvector extension via Helm..."

# Variable sanity check for required PostgreSQL variables
REQUIRED_VARS=(POSTGRES_RELEASE_NAME POSTGRES_USER POSTGRES_PASSWORD POSTGRES_DB POSTGRES_IMAGE_TAG POSTGRES_NODEPORT)
MISSING=()
for var in "${REQUIRED_VARS[@]}"; do
  if [[ -z "${!var}" ]]; then
    MISSING+=("$var")
  fi
done
if (( ${#MISSING[@]} > 0 )); then
  echo "[ERROR] The following required PostgreSQL variables are missing or empty:" | tee -a "$LOGFILE"
  for var in "${MISSING[@]}"; do
    echo "  $var='${!var}'" | tee -a "$LOGFILE"
  done
  exit 1
fi

# Create ConfigMap for pgvector init script (idempotent)
kubectl create configmap pgvector-init-script \
  --from-literal=init.sql="CREATE EXTENSION IF NOT EXISTS vector;" \
  -n "$NAMESPACE" 2>>"$LOGFILE" 1>>"$LOGFILE" || kubectl create configmap pgvector-init-script \
  --from-literal=init.sql="CREATE EXTENSION IF NOT EXISTS vector;" \
  -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - 2>>"$LOGFILE" 1>>"$LOGFILE"

helm repo add bitnami https://charts.bitnami.com/bitnami >>"$LOGFILE" 2>&1
helm repo update >>"$LOGFILE" 2>&1

# Helm dry-run for debugging
helm upgrade --install "$POSTGRES_RELEASE_NAME" bitnami/postgresql \
  --namespace "$NAMESPACE" \
  --set postgresqlUsername="$POSTGRES_USER" \
  --set postgresqlPassword="$POSTGRES_PASSWORD" \
  --set postgresqlDatabase="$POSTGRES_DB" \
  --set primary.initdb.scriptsConfigMap=pgvector-init-script \
  --set image.tag="$POSTGRES_IMAGE_TAG" \
  --set service.type=NodePort \
  --set service.nodePorts.postgresql="$POSTGRES_NODEPORT" \
  --debug --dry-run | tee -a "$LOGFILE"

# Actual install with error handling
if ! helm upgrade --install "$POSTGRES_RELEASE_NAME" bitnami/postgresql \
  --namespace "$NAMESPACE" \
  --set postgresqlUsername="$POSTGRES_USER" \
  --set postgresqlPassword="$POSTGRES_PASSWORD" \
  --set postgresqlDatabase="$POSTGRES_DB" \
  --set primary.initdb.scriptsConfigMap=pgvector-init-script \
  --set image.tag="$POSTGRES_IMAGE_TAG" \
  --set service.type=NodePort \
  --set service.nodePorts.postgresql="$POSTGRES_NODEPORT" \
  >>"$LOGFILE" 2>&1; then
  echo "[ERROR] PostgreSQL Helm install failed. Check $LOGFILE for details." | tee -a "$LOGFILE"
  exit 1
fi

# Wait for PostgreSQL pod to be ready
echo "[DEBUG] Entering wait_for_ready postgresql" | tee -a "$LOGFILE"
wait_for_ready postgresql
echo "[DEBUG] Exited wait_for_ready postgresql with status $?" | tee -a "$LOGFILE"
echo "[DEBUG] About to call step_done for PostgreSQL" | tee -a "$LOGFILE"
step_done "PostgreSQL with pgvector installed."
echo "[DEBUG] After step_done PostgreSQL" | tee -a "$LOGFILE"

# --- SCDF Install ---
step_major "Installing Spring Cloud Data Flow includes Skipper & MariaDB..."
helm upgrade --install scdf oci://registry-1.docker.io/bitnamicharts/spring-cloud-dataflow \
  --namespace "$NAMESPACE" \
  --values resources/scdf-values.yaml \
  --set rabbitmq.enabled=false \
  --set rabbitmq.host=scdf-rabbitmq \
  --set rabbitmq.username=user \
  --set rabbitmq.password=bitnami \
  --set server.service.type=NodePort \
  --set server.service.nodePort=30080 \
  >>"$LOGFILE" 2>&1 || true
step_done "Spring Cloud Data Flow installed."

# --- Wait for SCDF Server and Skipper to be Ready ---
step_major "Waiting for SCDF server and skipper pods to be ready..."
wait_for_ready scdf-spring-cloud-dataflow-server 300
wait_for_ready scdf-spring-cloud-dataflow-skipper 300

# --- Patch RabbitMQ Config into SCDF/Skipper ---
patch_scdf_rabbitmq_config

# --- SCDF Shell ---
download_shell_jar

# --- Register Default Apps as Maven Artifacts ---
register_default_apps_maven >>"$LOGFILE" 2>&1

# --- Debugging and Verification Steps ---
step_major "SCDF Debug: Print registered apps after registration"
echo "========= Registered apps after batch registration =========" | tee -a "$LOGFILE"
curl -s "$SCDF_SERVER_URL/apps" | tee -a "$LOGFILE"

step_major "SCDF Debug: Print SCDF server pod status"
kubectl get pods -n "$NAMESPACE" | tee -a "$LOGFILE"

step_major "SCDF Debug: Print SCDF server logs last 50 lines"
SCDF_POD=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/component=server -o jsonpath='{.items[0].metadata.name}')
kubectl logs "$SCDF_POD" -n "$NAMESPACE" --tail=50 | tee -a "$LOGFILE"

step_major "SCDF Debug: Print PostgreSQL pod status"
kubectl get pods -n "$NAMESPACE" | grep postgresql | tee -a "$LOGFILE"

step_major "SCDF Debug: Print PostgreSQL pod logs last 20 lines"
PG_POD=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=postgresql -o jsonpath='{.items[0].metadata.name}')
kubectl logs "$PG_POD" -n "$NAMESPACE" --tail=20 | tee -a "$LOGFILE"

step_major "SCDF Debug: Print Helm values for SCDF deployment"
helm get values scdf -n "$NAMESPACE" | tee -a "$LOGFILE"

# --- Verification ---
step_major "Querying registered apps for verification..."
curl -s "$SCDF_SERVER_URL/apps" > registered_apps.json
cat registered_apps.json >>"$LOGFILE"
step_done "Registered apps have been logged to registered_apps.json and $LOGFILE."
# --- MinIO Install ---
install_minio

# --- Print Management URLs ---
print_management_urls

exit 0
